use usb_device::class_prelude::*;

const MS_OS_STRING_DESCRIPTOR_INDEX: u8 = 0xEE;
const MS_OS_FEATURE_DESCRIPTOR_EXTENDED_COMPAT_ID: u16 = 0x0004;
const MS_OS_FEATURE_DESCRIPTOR_EXTENDED_PROPERTIES: u16 = 0x0005;

#[repr(u16)]
enum MsOsFeatureDescriptor {
  Genre = 0x0001,
  ExtendedCompatId = 0x0004,
  ExtendedProperties = 0x0005,
}

pub struct WinUsb {
  interface_num: u8,
}

impl WinUsb {
  pub fn new<B: UsbBus>(_alloc: &UsbBusAllocator<B>, interface_num: u8) -> WinUsb {
    assert_ne!(interface_num, 0);
    WinUsb {
      interface_num,
    }
  }
}

impl<B: UsbBus> UsbClass<B> for WinUsb {
  fn get_string(&self, index: StringIndex, _lang_id: u16) -> Option<&str> {
    if u8::from(index) == MS_OS_STRING_DESCRIPTOR_INDEX {
      return Some("MSFT100!")
    }

    None
  }

  fn control_in(&mut self, xfer: ControlIn<B>) {
   let req = xfer.request();
   if req.direction == usb_device::UsbDirection::In &&
      req.request_type == usb_device::control::RequestType::Vendor &&
      req.recipient == usb_device::control::Recipient::Device {
      if req.request == '!' as u8 {
        // Request is for an MS OS Feature Descriptor
        let interface_num: u8 = (req.value >> 8) as u8;
        let page_num: u8 = (req.value & 0xFF) as u8;
        assert_eq!(interface_num, 0);
        assert_eq!(page_num, 0);
        if page_num != 0 {
          match req.index {
            MS_OS_FEATURE_DESCRIPTOR_EXTENDED_COMPAT_ID => {
              //TODO: support multiple interface numbers
              let resp: &mut [u8] = &mut [
                0x28, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x01, 0x57, 0x49, 0x4E, 0x55, 0x53, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              ];
              resp[16] = self.interface_num;
              xfer.accept_with(resp).unwrap();
              panic!();
            },
            MS_OS_FEATURE_DESCRIPTOR_EXTENDED_PROPERTIES => {
              let resp: &[u8] = &[
                0x8E, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x00, 0x01, 0x00,
                0x84, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x28, 0x00,
                0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x66, 0x00, 0x61, 0x00, 0x63, 0x00, 0x65, 0x00, 0x47, 0x00, 0x55, 0x00, 0x49, 0x00, 0x44, 0x00, 0x73, 0x00,
                0x4E, 0x00, 0x00, 0x00,
                0x7B, 0x00, 0x30, 0x00, 0x32, 0x00, 0x36, 0x00, 0x33, 0x00, 0x62, 0x00, 0x35, 0x00, 0x31, 0x00, 0x32, 0x00, 0x2D, 0x00, 0x38, 0x00, 0x38, 0x00, 0x63, 0x00, 0x62, 0x00, 0x2D, 0x00, 0x34, 0x00, 0x31, 0x00, 0x33, 0x00, 0x36, 0x00, 0x2D, 0x00, 0x39, 0x00, 0x36, 0x00, 0x31, 0x00, 0x33, 0x00, 0x2D, 0x00, 0x35, 0x00, 0x63, 0x00, 0x38, 0x00, 0x65, 0x00, 0x31, 0x00, 0x30, 0x00, 0x39, 0x00, 0x64, 0x00, 0x38, 0x00, 0x65, 0x00, 0x66, 0x00, 0x35, 0x00, 0x7D, 0x00, 0x00, 0x00,
              ];
              xfer.accept_with(resp).unwrap();
              panic!();
            },
            _ => xfer.reject().unwrap(),
          }
        }
      }
    }
  }
}
